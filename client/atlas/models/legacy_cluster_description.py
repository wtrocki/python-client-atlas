# coding: utf-8

"""
    MongoDB Atlas Administration API

    The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.  # noqa: E501

    The version of the OpenAPI document: 2.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import annotations
from inspect import getfullargspec
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import Dict, List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, confloat, conint, constr, validator
from atlas.models.auto_scaling import AutoScaling
from atlas.models.bi_connector import BiConnector
from atlas.models.cluster_description_connection_strings import ClusterDescriptionConnectionStrings
from atlas.models.cluster_provider_settings import ClusterProviderSettings
from atlas.models.legacy_replication_spec import LegacyReplicationSpec
from atlas.models.link import Link
from atlas.models.nds_label import NDSLabel
from atlas.models.region_spec import RegionSpec

class LegacyClusterDescription(BaseModel):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """
    auto_scaling: Optional[AutoScaling] = Field(None, alias="autoScaling")
    backup_enabled: Optional[StrictBool] = Field(None, alias="backupEnabled", description="Flag that indicates whether the cluster can perform backups. If set to `true`, the cluster can perform backups. You must set this value to `true` for NVMe clusters. Backup uses Cloud Backups for dedicated clusters and Shared Cluster Backups for tenant clusters. If set to `false`, the cluster doesn't use MongoDB Cloud backups.")
    bi_connector: Optional[BiConnector] = Field(None, alias="biConnector")
    cluster_type: Optional[StrictStr] = Field(None, alias="clusterType", description="Configuration of nodes that comprise the cluster.")
    connection_strings: Optional[ClusterDescriptionConnectionStrings] = Field(None, alias="connectionStrings")
    create_date: Optional[datetime] = Field(None, alias="createDate", description="Date and time when MongoDB Cloud created this serverless instance. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.")
    disk_size_gb: Optional[confloat(le=4096, ge=10, strict=True)] = Field(None, alias="diskSizeGB", description="Storage capacity that the host's root volume possesses expressed in gigabytes. Increase this number to add capacity. MongoDB Cloud requires this parameter if you set **replicationSpecs**. If you specify a disk size below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.")
    encryption_at_rest_provider: Optional[StrictStr] = Field(None, alias="encryptionAtRestProvider", description="Cloud service provider that manages your customer keys to provide an additional layer of Encryption at Rest for the cluster.")
    group_id: Optional[constr(strict=True, max_length=24, min_length=24)] = Field(None, alias="groupId", description="Unique 24-hexadecimal character string that identifies the project.")
    id: Optional[constr(strict=True, max_length=24, min_length=24)] = Field(None, description="Unique 24-hexadecimal digit string that identifies the cluster.")
    labels: Optional[List[NDSLabel]] = Field(None, description="Collection of key-value pairs between 1 to 255 characters in length that tag and categorize the cluster. The MongoDB Cloud console doesn't display your labels.")
    links: Optional[List[Link]] = Field(None, description="List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships.")
    mongo_db_major_version: Optional[StrictStr] = Field('5.0', alias="mongoDBMajorVersion", description="Major MongoDB version of the cluster. MongoDB Cloud deploys the cluster with the latest stable release of the specified version.")
    mongo_db_version: Optional[constr(strict=True)] = Field(None, alias="mongoDBVersion", description="Version of MongoDB that the cluster runs.")
    mongo_uri: Optional[StrictStr] = Field(None, alias="mongoURI", description="Base connection string that you can use to connect to the cluster. MongoDB Cloud displays the string only after the cluster starts, not while it builds the cluster.")
    mongo_uri_updated: Optional[datetime] = Field(None, alias="mongoURIUpdated", description="Date and time when someone last updated the connection string. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.")
    mongo_uri_with_options: Optional[StrictStr] = Field(None, alias="mongoURIWithOptions", description="Connection string that you can use to connect to the cluster including the `replicaSet`, `ssl`, and `authSource` query parameters with values appropriate for the cluster. You may need to add MongoDB database users. The response returns this parameter once the cluster can receive requests, not while it builds the cluster.")
    name: Optional[constr(strict=True, max_length=64, min_length=1)] = Field(None, description="Human-readable label that identifies the cluster.")
    num_shards: Optional[conint(strict=True, le=50, ge=1)] = Field(1, alias="numShards", description="Number of shards up to 50 to deploy for a sharded cluster. The resource returns `1` to indicate a replica set and values of `2` and higher to indicate a sharded cluster. The returned value equals the number of shards in the cluster.")
    paused: Optional[StrictBool] = Field(None, description="Flag that indicates whether the cluster is paused.")
    pit_enabled: Optional[StrictBool] = Field(None, alias="pitEnabled", description="Flag that indicates whether the cluster uses continuous cloud backups.")
    provider_backup_enabled: Optional[StrictBool] = Field(None, alias="providerBackupEnabled", description="Flag that indicates whether the M10 or higher cluster can perform Cloud Backups. If set to `true`, the cluster can perform backups. If this and **backupEnabled** are set to `false`, the cluster doesn't use MongoDB Cloud backups.")
    provider_settings: Optional[ClusterProviderSettings] = Field(None, alias="providerSettings")
    replication_factor: Optional[StrictInt] = Field(self::Replication_factorEnum_NUMBER_3, alias="replicationFactor", description="Number of members that belong to the replica set. Each member retains a copy of your databases, providing high availability and data redundancy. Use **replicationSpecs** instead.")
    replication_spec: Optional[Dict[str, RegionSpec]] = Field(None, alias="replicationSpec", description="Physical location where MongoDB Cloud provisions cluster nodes.")
    replication_specs: Optional[List[LegacyReplicationSpec]] = Field(None, alias="replicationSpecs", description="List of settings that configure your cluster regions.  - For Global Clusters, each object in the array represents one zone where MongoDB Cloud deploys your clusters nodes. - For non-Global sharded clusters and replica sets, the single object represents where MongoDB Cloud deploys your clusters nodes.")
    root_cert_type: Optional[StrictStr] = Field('ISRGROOTX1', alias="rootCertType", description="Root Certificate Authority that MongoDB Atlas clusters uses. MongoDB Cloud supports Internet Security Research Group.")
    srv_address: Optional[StrictStr] = Field(None, alias="srvAddress", description="Connection string that you can use to connect to the cluster. The `+srv` modifier forces the connection to use Transport Layer Security (TLS). The `mongoURI` parameter lists additional options.")
    state_name: Optional[StrictStr] = Field(None, alias="stateName", description="Human-readable label that indicates the current operating condition of the cluster.")
    termination_protection_enabled: Optional[StrictBool] = Field(False, alias="terminationProtectionEnabled", description="Flag that indicates whether termination protection is enabled on the cluster. If set to `true`, MongoDB Cloud won't delete the cluster. If set to `false`, MongoDB Cloud will delete the cluster.")
    version_release_system: Optional[StrictStr] = Field('LTS', alias="versionReleaseSystem", description="Method by which the cluster maintains the MongoDB versions. If value is `CONTINUOUS`, you must not specify **mongoDBMajorVersion**.")
    __properties = ["autoScaling", "backupEnabled", "biConnector", "clusterType", "connectionStrings", "createDate", "diskSizeGB", "encryptionAtRestProvider", "groupId", "id", "labels", "links", "mongoDBMajorVersion", "mongoDBVersion", "mongoURI", "mongoURIUpdated", "mongoURIWithOptions", "name", "numShards", "paused", "pitEnabled", "providerBackupEnabled", "providerSettings", "replicationFactor", "replicationSpec", "replicationSpecs", "rootCertType", "srvAddress", "stateName", "terminationProtectionEnabled", "versionReleaseSystem"]

    @validator('cluster_type')
    def cluster_type_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('REPLICASET', 'SHARDED', 'GEOSHARDED'):
            raise ValueError("must validate the enum values ('REPLICASET', 'SHARDED', 'GEOSHARDED')")
        return v

    @validator('encryption_at_rest_provider')
    def encryption_at_rest_provider_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('NONE', 'AWS', 'AZURE', 'GCP'):
            raise ValueError("must validate the enum values ('NONE', 'AWS', 'AZURE', 'GCP')")
        return v

    @validator('group_id')
    def group_id_validate_regular_expression(cls, v):
        if not re.match(r"^([a-f0-9]{24})$", v):
            raise ValueError(r"must validate the regular expression /^([a-f0-9]{24})$/")
        return v

    @validator('id')
    def id_validate_regular_expression(cls, v):
        if not re.match(r"^([a-f0-9]{24})$", v):
            raise ValueError(r"must validate the regular expression /^([a-f0-9]{24})$/")
        return v

    @validator('mongo_db_major_version')
    def mongo_db_major_version_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('4.2', '4.4', '5.0', '6.0'):
            raise ValueError("must validate the enum values ('4.2', '4.4', '5.0', '6.0')")
        return v

    @validator('mongo_db_version')
    def mongo_db_version_validate_regular_expression(cls, v):
        if not re.match(r"([\d]+\.[\d]+\.[\d]+)", v):
            raise ValueError(r"must validate the regular expression /([\d]+\.[\d]+\.[\d]+)/")
        return v

    @validator('name')
    def name_validate_regular_expression(cls, v):
        if not re.match(r"^([a-zA-Z0-9]([a-zA-Z0-9-]){0,21}(?<!-)([\w]{0,42}))$", v):
            raise ValueError(r"must validate the regular expression /^([a-zA-Z0-9]([a-zA-Z0-9-]){0,21}(?<!-)([\w]{0,42}))$/")
        return v

    @validator('replication_factor')
    def replication_factor_validate_enum(cls, v):
        if v is None:
            return v

        if v not in (3, 5, 7):
            raise ValueError("must validate the enum values (3, 5, 7)")
        return v

    @validator('root_cert_type')
    def root_cert_type_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('ISRGROOTX1'):
            raise ValueError("must validate the enum values ('ISRGROOTX1')")
        return v

    @validator('state_name')
    def state_name_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('IDLE', 'CREATING', 'UPDATING', 'DELETING', 'DELETED', 'REPAIRING'):
            raise ValueError("must validate the enum values ('IDLE', 'CREATING', 'UPDATING', 'DELETING', 'DELETED', 'REPAIRING')")
        return v

    @validator('version_release_system')
    def version_release_system_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('LTS', 'CONTINUOUS'):
            raise ValueError("must validate the enum values ('LTS', 'CONTINUOUS')")
        return v

    class Config:
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> LegacyClusterDescription:
        """Create an instance of LegacyClusterDescription from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                            "create_date",
                            "group_id",
                            "id",
                            "links",
                            "mongo_uri",
                            "mongo_uri_updated",
                            "mongo_uri_with_options",
                            "srv_address",
                            "state_name",
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of auto_scaling
        if self.auto_scaling:
            _dict['autoScaling'] = self.auto_scaling.to_dict()
        # override the default output from pydantic by calling `to_dict()` of bi_connector
        if self.bi_connector:
            _dict['biConnector'] = self.bi_connector.to_dict()
        # override the default output from pydantic by calling `to_dict()` of connection_strings
        if self.connection_strings:
            _dict['connectionStrings'] = self.connection_strings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in labels (list)
        _items = []
        if self.labels:
            for _item in self.labels:
                if _item:
                    _items.append(_item.to_dict())
            _dict['labels'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in links (list)
        _items = []
        if self.links:
            for _item in self.links:
                if _item:
                    _items.append(_item.to_dict())
            _dict['links'] = _items
        # override the default output from pydantic by calling `to_dict()` of provider_settings
        if self.provider_settings:
            _dict['providerSettings'] = self.provider_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in replication_spec (dict)
        _field_dict = {}
        if self.replication_spec:
            for _key in self.replication_spec:
                if self.replication_spec[_key]:
                    _field_dict[_key] = self.replication_spec[_key].to_dict()
            _dict['replicationSpec'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each item in replication_specs (list)
        _items = []
        if self.replication_specs:
            for _item in self.replication_specs:
                if _item:
                    _items.append(_item.to_dict())
            _dict['replicationSpecs'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> LegacyClusterDescription:
        """Create an instance of LegacyClusterDescription from a dict"""
        if obj is None:
            return None

        if type(obj) is not dict:
            return LegacyClusterDescription.parse_obj(obj)

        _obj = LegacyClusterDescription.parse_obj({
            "auto_scaling": AutoScaling.from_dict(obj.get("autoScaling")) if obj.get("autoScaling") is not None else None,
            "backup_enabled": obj.get("backupEnabled"),
            "bi_connector": BiConnector.from_dict(obj.get("biConnector")) if obj.get("biConnector") is not None else None,
            "cluster_type": obj.get("clusterType"),
            "connection_strings": ClusterDescriptionConnectionStrings.from_dict(obj.get("connectionStrings")) if obj.get("connectionStrings") is not None else None,
            "create_date": obj.get("createDate"),
            "disk_size_gb": obj.get("diskSizeGB"),
            "encryption_at_rest_provider": obj.get("encryptionAtRestProvider"),
            "group_id": obj.get("groupId"),
            "id": obj.get("id"),
            "labels": [NDSLabel.from_dict(_item) for _item in obj.get("labels")] if obj.get("labels") is not None else None,
            "links": [Link.from_dict(_item) for _item in obj.get("links")] if obj.get("links") is not None else None,
            "mongo_db_major_version": obj.get("mongoDBMajorVersion") if obj.get("mongoDBMajorVersion") is not None else '5.0',
            "mongo_db_version": obj.get("mongoDBVersion"),
            "mongo_uri": obj.get("mongoURI"),
            "mongo_uri_updated": obj.get("mongoURIUpdated"),
            "mongo_uri_with_options": obj.get("mongoURIWithOptions"),
            "name": obj.get("name"),
            "num_shards": obj.get("numShards") if obj.get("numShards") is not None else 1,
            "paused": obj.get("paused"),
            "pit_enabled": obj.get("pitEnabled"),
            "provider_backup_enabled": obj.get("providerBackupEnabled"),
            "provider_settings": ClusterProviderSettings.from_dict(obj.get("providerSettings")) if obj.get("providerSettings") is not None else None,
            "replication_factor": obj.get("replicationFactor") if obj.get("replicationFactor") is not None else self::Replication_factorEnum_NUMBER_3,
            "replication_spec": dict((_k, Dict[str, RegionSpec].from_dict(_v)) for _k, _v in obj.get("replicationSpec").items()),
            "replication_specs": [LegacyReplicationSpec.from_dict(_item) for _item in obj.get("replicationSpecs")] if obj.get("replicationSpecs") is not None else None,
            "root_cert_type": obj.get("rootCertType") if obj.get("rootCertType") is not None else 'ISRGROOTX1',
            "srv_address": obj.get("srvAddress"),
            "state_name": obj.get("stateName"),
            "termination_protection_enabled": obj.get("terminationProtectionEnabled") if obj.get("terminationProtectionEnabled") is not None else False,
            "version_release_system": obj.get("versionReleaseSystem") if obj.get("versionReleaseSystem") is not None else 'LTS'
        })
        return _obj

