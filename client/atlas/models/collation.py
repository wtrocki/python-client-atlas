# coding: utf-8

"""
    MongoDB Atlas Administration API

    The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.  # noqa: E501

    The version of the OpenAPI document: 2.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import annotations
from inspect import getfullargspec
import pprint
import re  # noqa: F401
import json


from typing import Optional
from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, validator

class Collation(BaseModel):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """
    alternate: Optional[StrictStr] = Field('non-ignorable', description="Method to handle whitespace and punctuation as base characters for purposes of comparison.  | Value | Evaluate Whitespace and Punctuation as Base Characters | |---|---| | `\"non-ignorable\"` | Yes | | `\"shifted\"` | No. MongoDB Cloud distinguishes these characters when `\"strength\" > 3`. | ")
    backwards: Optional[StrictBool] = Field(False, description="Flag that indicates whether strings with diacritics sort from back of the string. Some French dictionary orders strings in this way.  | Value | String Comparison Method |  |---|---| | `true` | Compare from back to front. | | `false` | Compare from front to back. | ")
    case_first: Optional[StrictStr] = Field('false', alias="caseFirst", description="Method to handle sort order of case differences during tertiary level comparisons.  | Value | Sort Order Method |  |---|---|  | `\"upper\"` | Uppercase sorts before lowercase. |  | `\"lower\"` | Lowercase sorts before uppercase. |  | `\"off\"` | Similar to \"lower\" with slight differences. | ")
    case_level: Optional[StrictBool] = Field(False, alias="caseLevel", description="Flag that indicates whether to include case comparison when `\"strength\" : 1` or `\"strength\" : 2`.  | Value | Compare case at level 1 or 2? | Strength Level | Comparisons Include |  |---|---|---|---|  | true | Yes | 1 | Base characters and case. |  |  |  | 2 | Base characters, diacritics (and possible other secondary differences),   and case. |  | false | No |  |  | ")
    locale: StrictStr = Field(..., description="International Components for Unicode (ICU) code that represents a localized language. To specify simple binary comparison, set `\"locale\" : \"simple\"`.")
    max_variable: Optional[StrictStr] = Field(None, alias="maxVariable", description="Field that indicates which characters can be ignored when `\"alternate\" : \"shifted\"`. This has no affect if `\"alternate\" : \"non-ignorable\"`.  | Value | Ignore |  |---|---| | `\"punct\"` | Both whitespace and punctuation | | `\"space\"` | Whitespace | ")
    normalization: Optional[StrictBool] = Field(False, description="Flag that indicates whether to check if the text requires normalization and then perform it. Most text doesn't require this normalization processing.  | Value | Normalization Method |  |---|---| | `true` | Yes, check if fully normalized and perform normalization to compare text. | | `false` | No, don't check. | ")
    numeric_ordering: Optional[StrictBool] = Field(False, alias="numericOrdering", description="Flag that indicates whether to compare sequences of digits as numbers or as strings.  | Value | Comparison Method |  |---|---| | `true` | Compare as numbers. This results in `10 > 2`. | | `false` | Compare as strings. This results in `\"10\" < \"2\"`. | ")
    strength: Optional[conint(strict=True, le=5, ge=1)] = Field(3, description="Degree of comparison to perform when sorting words. MongoDB Cloud accepts the following values:  | Value | Comparison Level | Comparison Method | |---|---|---| | 1 | Primary | Compares the base characters only, ignoring other differences such as diacritics and case. | | 2 | Secondary | Compares base characters (primary) and diacritics (secondary). Primary differences take precedence over secondary differences. | | 3 | Tertiary | Compares base characters (primary), diacritics (secondary), and case and variants (tertiary). Differences between base characters takes precedence over secondary differences which take precedence over tertiary differences. | | 4 | Quaternary | Compares for the specific use case to consider punctuation when levels 1 through 3 ignore punctuation or for processing Japanese text. | | 5 | Identical | Compares for the specific use case of tie breaker. | ")
    __properties = ["alternate", "backwards", "caseFirst", "caseLevel", "locale", "maxVariable", "normalization", "numericOrdering", "strength"]

    @validator('alternate')
    def alternate_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('non-ignorable', 'shifted'):
            raise ValueError("must validate the enum values ('non-ignorable', 'shifted')")
        return v

    @validator('case_first')
    def case_first_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('lower', 'false', 'upper'):
            raise ValueError("must validate the enum values ('lower', 'false', 'upper')")
        return v

    @validator('locale')
    def locale_validate_enum(cls, v):
        if v not in ('af', 'sq', 'am', 'ar', 'hy', 'as', 'az', 'bn', 'be', 'bs', 'bs_Cyrl', 'bg', 'my', 'ca', 'chr', 'zh', 'zh_Hant', 'hr', 'cs', 'da', 'nl', 'dz', 'en', 'en_US', 'en_US_POSIX', 'eo', 'et', 'ee', 'fo', 'fil', 'fi_FI', 'fr', 'fr_CA', 'gl', 'ka', 'de', 'de_AT', 'el', 'gu', 'ha', 'haw', 'he', 'hi', 'hu', 'is', 'ig', 'smn', 'id', 'ga', 'it', 'ja', 'kl', 'kn', 'kk', 'km', 'kok', 'ko', 'ky', 'lk', 'lo', 'lv', 'li', 'lt', 'dsb', 'lb', 'mk', 'ms', 'ml', 'mt', 'mr', 'mn', 'ne', 'se', 'nb', 'nn', 'or', 'om', 'ps', 'fa', 'fa_AF', 'pl', 'pt', 'pa', 'ro', 'ru', 'sr', 'sr_Latn', 'si', 'sk', 'sl', 'es', 'sw', 'sv', 'ta', 'te', 'th', 'bo', 'to', 'tr', 'uk', 'hsb', 'ur', 'ug', 'vi', 'wae', 'cy', 'yi', 'yo', 'zu'):
            raise ValueError("must validate the enum values ('af', 'sq', 'am', 'ar', 'hy', 'as', 'az', 'bn', 'be', 'bs', 'bs_Cyrl', 'bg', 'my', 'ca', 'chr', 'zh', 'zh_Hant', 'hr', 'cs', 'da', 'nl', 'dz', 'en', 'en_US', 'en_US_POSIX', 'eo', 'et', 'ee', 'fo', 'fil', 'fi_FI', 'fr', 'fr_CA', 'gl', 'ka', 'de', 'de_AT', 'el', 'gu', 'ha', 'haw', 'he', 'hi', 'hu', 'is', 'ig', 'smn', 'id', 'ga', 'it', 'ja', 'kl', 'kn', 'kk', 'km', 'kok', 'ko', 'ky', 'lk', 'lo', 'lv', 'li', 'lt', 'dsb', 'lb', 'mk', 'ms', 'ml', 'mt', 'mr', 'mn', 'ne', 'se', 'nb', 'nn', 'or', 'om', 'ps', 'fa', 'fa_AF', 'pl', 'pt', 'pa', 'ro', 'ru', 'sr', 'sr_Latn', 'si', 'sk', 'sl', 'es', 'sw', 'sv', 'ta', 'te', 'th', 'bo', 'to', 'tr', 'uk', 'hsb', 'ur', 'ug', 'vi', 'wae', 'cy', 'yi', 'yo', 'zu')")
        return v

    @validator('max_variable')
    def max_variable_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('punct', 'space'):
            raise ValueError("must validate the enum values ('punct', 'space')")
        return v

    class Config:
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Collation:
        """Create an instance of Collation from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Collation:
        """Create an instance of Collation from a dict"""
        if obj is None:
            return None

        if type(obj) is not dict:
            return Collation.parse_obj(obj)

        _obj = Collation.parse_obj({
            "alternate": obj.get("alternate") if obj.get("alternate") is not None else 'non-ignorable',
            "backwards": obj.get("backwards") if obj.get("backwards") is not None else False,
            "case_first": obj.get("caseFirst") if obj.get("caseFirst") is not None else 'false',
            "case_level": obj.get("caseLevel") if obj.get("caseLevel") is not None else False,
            "locale": obj.get("locale"),
            "max_variable": obj.get("maxVariable"),
            "normalization": obj.get("normalization") if obj.get("normalization") is not None else False,
            "numeric_ordering": obj.get("numericOrdering") if obj.get("numericOrdering") is not None else False,
            "strength": obj.get("strength") if obj.get("strength") is not None else 3
        })
        return _obj

