# coding: utf-8

"""
    MongoDB Atlas Administration API

    The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.  # noqa: E501

    The version of the OpenAPI document: 2.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import annotations
from inspect import getfullargspec
import pprint
import re  # noqa: F401
import json


from typing import Optional
from pydantic import BaseModel, Field, StrictStr, conint, validator
from atlas.models.hardware_spec import HardwareSpec

class TenantRegionConfig(BaseModel):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """
    backing_provider_name: Optional[StrictStr] = Field(None, alias="backingProviderName", description="Cloud service provider on which MongoDB Cloud provisioned the multi-tenant cluster. The resource returns this parameter when **providerSettings.providerName** is `TENANT` and **providerSetting.instanceSizeName** is `M2` or `M5`.")
    electable_specs: Optional[HardwareSpec] = Field(None, alias="electableSpecs")
    priority: Optional[conint(strict=True, le=7, ge=0)] = Field(None, description="Precedence is given to this region when a primary election occurs. If your **regionConfigs** has only **readOnlySpecs**, **analyticsSpecs**, or both, set this value to `0`. If you have multiple **regionConfigs** objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is `7`.  **Example:** If you have three regions, their priorities would be `7`, `6`, and `5` respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be `4` and `3` respectively.")
    provider_name: Optional[StrictStr] = Field(None, alias="providerName", description="Cloud service provider on which MongoDB Cloud provisions the hosts. Set dedicated clusters to `AWS`, `GCP`, `AZURE` or `TENANT`.")
    region_name: Optional[StrictStr] = Field(None, alias="regionName", description="Physical location of your MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Cloud deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Cloud creates them as part of the deployment. It assigns the VPC a Classless Inter-Domain Routing (CIDR) block. To limit a new VPC peering connection to one Classless Inter-Domain Routing (CIDR) block and region, create the connection first. Deploy the cluster after the connection starts. GCP Clusters and Multi-region clusters require one VPC peering connection for each region. MongoDB nodes can use only the peering connection that resides in the same region as the nodes to communicate with the peered VPC.")
    __properties = ["backingProviderName", "electableSpecs", "priority", "providerName", "regionName"]

    @validator('backing_provider_name')
    def backing_provider_name_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('AWS', 'GCP', 'AZURE'):
            raise ValueError("must validate the enum values ('AWS', 'GCP', 'AZURE')")
        return v

    @validator('provider_name')
    def provider_name_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('AWS', 'AZURE', 'GCP', 'TENANT'):
            raise ValueError("must validate the enum values ('AWS', 'AZURE', 'GCP', 'TENANT')")
        return v

    @validator('region_name')
    def region_name_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('US_GOV_WEST_1', 'US_GOV_EAST_1', 'US_EAST_1', 'US_EAST_2', 'US_WEST_1', 'US_WEST_2', 'CA_CENTRAL_1', 'EU_NORTH_1', 'EU_WEST_1', 'EU_WEST_2', 'EU_WEST_3', 'EU_CENTRAL_1', 'AP_EAST_1', 'AP_NORTHEAST_1', 'AP_NORTHEAST_2', 'AP_NORTHEAST_3', 'AP_SOUTHEAST_1', 'AP_SOUTHEAST_2', 'AP_SOUTHEAST_3', 'AP_SOUTH_1', 'SA_EAST_1', 'CN_NORTH_1', 'CN_NORTHWEST_1', 'ME_SOUTH_1', 'AF_SOUTH_1', 'EU_SOUTH_1', 'GLOBAL', 'US_CENTRAL', 'US_EAST', 'US_NORTH_CENTRAL', 'US_WEST', 'US_SOUTH_CENTRAL', 'EUROPE_NORTH', 'EUROPE_WEST', 'US_WEST_CENTRAL', 'US_WEST_3', 'CANADA_EAST', 'CANADA_CENTRAL', 'BRAZIL_SOUTH', 'BRAZIL_SOUTHEAST', 'AUSTRALIA_CENTRAL', 'AUSTRALIA_CENTRAL_2', 'AUSTRALIA_EAST', 'AUSTRALIA_SOUTH_EAST', 'GERMANY_CENTRAL', 'GERMANY_NORTH_EAST', 'GERMANY_WEST_CENTRAL', 'GERMANY_NORTH', 'SWEDEN_CENTRAL', 'SWEDEN_SOUTH', 'SWITZERLAND_NORTH', 'SWITZERLAND_WEST', 'UK_SOUTH', 'UK_WEST', 'NORWAY_EAST', 'NORWAY_WEST', 'INDIA_CENTRAL', 'INDIA_SOUTH', 'INDIA_WEST', 'CHINA_EAST', 'CHINA_NORTH', 'ASIA_EAST', 'JAPAN_EAST', 'JAPAN_WEST', 'ASIA_SOUTH_EAST', 'KOREA_CENTRAL', 'KOREA_SOUTH', 'FRANCE_CENTRAL', 'FRANCE_SOUTH', 'SOUTH_AFRICA_NORTH', 'SOUTH_AFRICA_WEST', 'UAE_CENTRAL', 'UAE_NORTH', 'EASTERN_US', 'US_EAST_4', 'US_WEST_4', 'CENTRAL_US', 'WESTERN_US', 'NORTH_AMERICA_NORTHEAST_1', 'NORTH_AMERICA_NORTHEAST_2', 'SOUTH_AMERICA_EAST_1', 'SOUTH_AMERICA_WEST_1', 'WESTERN_EUROPE', 'EUROPE_NORTH_1', 'EUROPE_WEST_2', 'EUROPE_WEST_3', 'EUROPE_WEST_4', 'EUROPE_WEST_6', 'EUROPE_WEST_8', 'EUROPE_WEST_9', 'EUROPE_SOUTHWEST_1', 'EUROPE_CENTRAL_2', 'AUSTRALIA_SOUTHEAST_1', 'AUSTRALIA_SOUTHEAST_2', 'EASTERN_ASIA_PACIFIC', 'NORTHEASTERN_ASIA_PACIFIC', 'SOUTHEASTERN_ASIA_PACIFIC', 'ASIA_EAST_2', 'ASIA_NORTHEAST_2', 'ASIA_NORTHEAST_3', 'ASIA_SOUTH_1', 'ASIA_SOUTH_2', 'ASIA_SOUTHEAST_2'):
            raise ValueError("must validate the enum values ('US_GOV_WEST_1', 'US_GOV_EAST_1', 'US_EAST_1', 'US_EAST_2', 'US_WEST_1', 'US_WEST_2', 'CA_CENTRAL_1', 'EU_NORTH_1', 'EU_WEST_1', 'EU_WEST_2', 'EU_WEST_3', 'EU_CENTRAL_1', 'AP_EAST_1', 'AP_NORTHEAST_1', 'AP_NORTHEAST_2', 'AP_NORTHEAST_3', 'AP_SOUTHEAST_1', 'AP_SOUTHEAST_2', 'AP_SOUTHEAST_3', 'AP_SOUTH_1', 'SA_EAST_1', 'CN_NORTH_1', 'CN_NORTHWEST_1', 'ME_SOUTH_1', 'AF_SOUTH_1', 'EU_SOUTH_1', 'GLOBAL', 'US_CENTRAL', 'US_EAST', 'US_NORTH_CENTRAL', 'US_WEST', 'US_SOUTH_CENTRAL', 'EUROPE_NORTH', 'EUROPE_WEST', 'US_WEST_CENTRAL', 'US_WEST_3', 'CANADA_EAST', 'CANADA_CENTRAL', 'BRAZIL_SOUTH', 'BRAZIL_SOUTHEAST', 'AUSTRALIA_CENTRAL', 'AUSTRALIA_CENTRAL_2', 'AUSTRALIA_EAST', 'AUSTRALIA_SOUTH_EAST', 'GERMANY_CENTRAL', 'GERMANY_NORTH_EAST', 'GERMANY_WEST_CENTRAL', 'GERMANY_NORTH', 'SWEDEN_CENTRAL', 'SWEDEN_SOUTH', 'SWITZERLAND_NORTH', 'SWITZERLAND_WEST', 'UK_SOUTH', 'UK_WEST', 'NORWAY_EAST', 'NORWAY_WEST', 'INDIA_CENTRAL', 'INDIA_SOUTH', 'INDIA_WEST', 'CHINA_EAST', 'CHINA_NORTH', 'ASIA_EAST', 'JAPAN_EAST', 'JAPAN_WEST', 'ASIA_SOUTH_EAST', 'KOREA_CENTRAL', 'KOREA_SOUTH', 'FRANCE_CENTRAL', 'FRANCE_SOUTH', 'SOUTH_AFRICA_NORTH', 'SOUTH_AFRICA_WEST', 'UAE_CENTRAL', 'UAE_NORTH', 'EASTERN_US', 'US_EAST_4', 'US_WEST_4', 'CENTRAL_US', 'WESTERN_US', 'NORTH_AMERICA_NORTHEAST_1', 'NORTH_AMERICA_NORTHEAST_2', 'SOUTH_AMERICA_EAST_1', 'SOUTH_AMERICA_WEST_1', 'WESTERN_EUROPE', 'EUROPE_NORTH_1', 'EUROPE_WEST_2', 'EUROPE_WEST_3', 'EUROPE_WEST_4', 'EUROPE_WEST_6', 'EUROPE_WEST_8', 'EUROPE_WEST_9', 'EUROPE_SOUTHWEST_1', 'EUROPE_CENTRAL_2', 'AUSTRALIA_SOUTHEAST_1', 'AUSTRALIA_SOUTHEAST_2', 'EASTERN_ASIA_PACIFIC', 'NORTHEASTERN_ASIA_PACIFIC', 'SOUTHEASTERN_ASIA_PACIFIC', 'ASIA_EAST_2', 'ASIA_NORTHEAST_2', 'ASIA_NORTHEAST_3', 'ASIA_SOUTH_1', 'ASIA_SOUTH_2', 'ASIA_SOUTHEAST_2')")
        return v

    class Config:
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> TenantRegionConfig:
        """Create an instance of TenantRegionConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of electable_specs
        if self.electable_specs:
            _dict['electableSpecs'] = self.electable_specs.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> TenantRegionConfig:
        """Create an instance of TenantRegionConfig from a dict"""
        if obj is None:
            return None

        if type(obj) is not dict:
            return TenantRegionConfig.parse_obj(obj)

        _obj = TenantRegionConfig.parse_obj({
            "backing_provider_name": obj.get("backingProviderName"),
            "electable_specs": HardwareSpec.from_dict(obj.get("electableSpecs")) if obj.get("electableSpecs") is not None else None,
            "priority": obj.get("priority"),
            "provider_name": obj.get("providerName"),
            "region_name": obj.get("regionName")
        })
        return _obj

