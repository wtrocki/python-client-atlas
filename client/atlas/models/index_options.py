# coding: utf-8

"""
    MongoDB Atlas Administration API

    The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.  # noqa: E501

    The version of the OpenAPI document: 2.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import annotations
from inspect import getfullargspec
import pprint
import re  # noqa: F401
import json


from typing import Any, Dict, Optional
from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr

class IndexOptions(BaseModel):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """
    var_2dsphere_index_version: StrictInt = Field(..., alias="2dsphereIndexVersion", description="Index version number applied to the 2dsphere index. MongoDB 3.2 and later use version 3. Use this option to override the default version number. This option applies to the **2dsphere** index type only.")
    background: Optional[StrictBool] = Field(False, description="Flag that indicates whether MongoDB should build the index in the background. This applies to MongoDB databases running feature compatibility version 4.0 or earlier. MongoDB databases running FCV 4.2 or later build indexes using an optimized build process. This process holds the exclusive lock only at the beginning and end of the build process. The rest of the build process yields to interleaving read and write operations. MongoDB databases running FCV 4.2 or later ignore this option. This option applies to all index types.")
    bits: Optional[StrictInt] = Field(26, description="Number of precision applied to the stored geohash value of the location data. This option applies to the **2d** index type only.")
    bucket_size: Optional[StrictInt] = Field(None, alias="bucketSize", description="Number of units within which to group the location values. You could group in the same bucket those location values within the specified number of units to each other. This option applies to the geoHaystack index type only.  MongoDB 5.0 removed geoHaystack Indexes and the `geoSearch` command.")
    default_language: Optional[StrictStr] = Field('english', description="Human language that determines the list of stop words and the rules for the stemmer and tokenizer. This option accepts the supported languages using its name in lowercase english or the ISO 639-2 code. If you set this parameter to `\"none\"`, then the text search uses simple tokenization with no list of stop words and no stemming. This option applies to the **text** index type only.")
    expire_after_seconds: Optional[StrictInt] = Field(None, alias="expireAfterSeconds", description="Number of seconds that MongoDB retains documents in a Time To Live (TTL) index.")
    hidden: Optional[StrictBool] = Field(False, description="Flag that determines whether the index is hidden from the query planner. A hidden index is not evaluated as part of the query plan selection.")
    language_override: Optional[StrictStr] = Field('language', description="Human-readable label that identifies the document parameter that contains the override language for the document. This option applies to the **text** index type only.")
    max: Optional[StrictInt] = Field(180, description="Upper inclusive boundary to limit the longitude and latitude values. This option applies to the 2d index type only.")
    min: Optional[StrictInt] = Field(-180, description="Lower inclusive boundary to limit the longitude and latitude values. This option applies to the 2d index type only.")
    name: Optional[StrictStr] = Field(None, description="Human-readable label that identifies this index. This option applies to all index types.")
    partial_filter_expression: Optional[Dict[str, Dict[str, Any]]] = Field(None, alias="partialFilterExpression", description="Rules that limit the documents that the index references to a filter expression. All MongoDB index types accept a **partialFilterExpression** option. **partialFilterExpression** can include following expressions:  - equality (`\"parameter\" : \"value\"` or using the `$eq` operator) - `\"$exists\": true` , maximum: `$gt`, `$gte`, `$lt`, `$lte` comparisons - `$type` - `$and` (top-level only)  This option applies to all index types.")
    sparse: Optional[StrictBool] = Field(False, description="Flag that indicates whether the index references documents that only have the specified parameter. These indexes use less space but behave differently in some situations like when sorting. The following index types default to sparse and ignore this option: `2dsphere`, `2d`, `geoHaystack`, `text`.  Compound indexes that includes one or more indexes with `2dsphere` keys alongside other key types, only the `2dsphere` index parameters determine which documents the index references. If you run MongoDB 3.2 or later, use partial indexes. This option applies to all index types.")
    storage_engine: Optional[Dict[str, Dict[str, Any]]] = Field(None, alias="storageEngine", description="Storage engine set for the specific index. This value can be set only at creation. This option uses the following format: `\"storageEngine\" : { \"<storage-engine-name>\" : \"<options>\" }` MongoDB validates storage engine configuration options when creating indexes. To support replica sets with members with different storage engines, MongoDB logs these options to the oplog during replication. This option applies to all index types.")
    text_index_version: Optional[StrictInt] = Field(3, alias="textIndexVersion", description="Version applied to this text index. MongoDB 3.2 and later use version `3`. Use this option to override the default version number. This option applies to the **text** index type only.")
    unique: Optional[StrictBool] = Field(False, description="Flag that indicates whether this index can accept insertion or update of documents when the index key value matches an existing index key value. Set `\"unique\" : true` to set this index as unique. You can't set a hashed index to be unique. This option applies to all index types.")
    weights: Optional[Dict[str, Dict[str, Any]]] = Field(None, description="Relative importance to place upon provided index parameters. This object expresses this as key/value pairs of index parameter and weight to apply to that parameter. You can specify weights for some or all the indexed parameters. The weight must be an integer between 1 and 99,999. MongoDB 5.0 and later can apply **weights** to **text** indexes only.")
    __properties = ["2dsphereIndexVersion", "background", "bits", "bucketSize", "default_language", "expireAfterSeconds", "hidden", "language_override", "max", "min", "name", "partialFilterExpression", "sparse", "storageEngine", "textIndexVersion", "unique", "weights"]

    class Config:
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> IndexOptions:
        """Create an instance of IndexOptions from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> IndexOptions:
        """Create an instance of IndexOptions from a dict"""
        if obj is None:
            return None

        if type(obj) is not dict:
            return IndexOptions.parse_obj(obj)

        _obj = IndexOptions.parse_obj({
            "var_2dsphere_index_version": obj.get("2dsphereIndexVersion") if obj.get("2dsphereIndexVersion") is not None else 3,
            "background": obj.get("background") if obj.get("background") is not None else False,
            "bits": obj.get("bits") if obj.get("bits") is not None else 26,
            "bucket_size": obj.get("bucketSize"),
            "default_language": obj.get("default_language") if obj.get("default_language") is not None else 'english',
            "expire_after_seconds": obj.get("expireAfterSeconds"),
            "hidden": obj.get("hidden") if obj.get("hidden") is not None else False,
            "language_override": obj.get("language_override") if obj.get("language_override") is not None else 'language',
            "max": obj.get("max") if obj.get("max") is not None else 180,
            "min": obj.get("min") if obj.get("min") is not None else -180,
            "name": obj.get("name"),
            "partial_filter_expression": obj.get("partialFilterExpression"),
            "sparse": obj.get("sparse") if obj.get("sparse") is not None else False,
            "storage_engine": obj.get("storageEngine"),
            "text_index_version": obj.get("textIndexVersion") if obj.get("textIndexVersion") is not None else 3,
            "unique": obj.get("unique") if obj.get("unique") is not None else False,
            "weights": obj.get("weights")
        })
        return _obj

