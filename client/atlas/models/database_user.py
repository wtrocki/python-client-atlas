# coding: utf-8

"""
    MongoDB Atlas Administration API

    The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.  # noqa: E501

    The version of the OpenAPI document: 2.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import annotations
from inspect import getfullargspec
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel, Field, StrictStr, constr, validator
from atlas.models.link import Link
from atlas.models.nds_label import NDSLabel
from atlas.models.role import Role
from atlas.models.user_scope import UserScope

class DatabaseUser(BaseModel):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """
    aws_iam_type: Optional[StrictStr] = Field('NONE', alias="awsIAMType", description="Human-readable label that indicates whether the new database user authenticates with the Amazon Web Services (AWS) Identity and Access Management (IAM) credentials associated with the user or the user's role.")
    database_name: StrictStr = Field(..., alias="databaseName", description="Database against which the database user authenticates. Database users must provide both a username and authentication database to log into MongoDB.")
    delete_after_date: Optional[datetime] = Field(None, alias="deleteAfterDate", description="Date and time when MongoDB Cloud deletes the user. This parameter expresses its value in the ISO 8601 timestamp format in UTC and can include the time zone designation. You must specify a future date that falls within one week of making the Application Programming Interface (API) request.")
    group_id: constr(strict=True, max_length=24, min_length=24) = Field(..., alias="groupId", description="Unique 24-hexadecimal digit string that identifies the project.")
    labels: Optional[List[NDSLabel]] = Field(None, description="List that contains the key-value pairs for tagging and categorizing the MongoDB database user. The labels that you define do not appear in the console.")
    ldap_auth_type: Optional[StrictStr] = Field('NONE', alias="ldapAuthType", description="Part of the Lightweight Directory Access Protocol (LDAP) record that the database uses to authenticate this database user on the LDAP host.")
    links: Optional[List[Link]] = Field(None, description="List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships.")
    password: Optional[constr(strict=True, min_length=8)] = Field(None, description="Alphanumeric string that authenticates this database user against the database specified in `databaseName`. To authenticate with SCRAM-SHA, you must specify this parameter. This parameter doesn't appear in this response.")
    roles: Optional[List[Role]] = Field(None, description="List that provides the pairings of one role with one applicable database.")
    scopes: Optional[List[UserScope]] = Field(None, description="List that contains clusters and MongoDB Atlas Data Lakes that this database user can access. If omitted, MongoDB Cloud grants the database user access to all the clusters and MongoDB Atlas Data Lakes in the project.")
    username: constr(strict=True, max_length=1024) = Field(..., description="Human-readable label that represents the user that authenticates to MongoDB. The format of this label depends on the method of authentication:  | Authentication Method | Parameter Needed | Parameter Value | username Format | |---|---|---|---| | AWS IAM | awsType | ROLE | <abbr title=\"Amazon Resource Name\">ARN</abbr> | | AWS IAM | awsType | USER | <abbr title=\"Amazon Resource Name\">ARN</abbr> | | x.509 | x509Type | CUSTOMER | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name | | x.509 | x509Type | MANAGED | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name | | LDAP | ldapAuthType | USER | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name | | LDAP | ldapAuthType | GROUP | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name | | SCRAM-SHA | awsType, x509Type, ldapAuthType | NONE | Alphanumeric string | ")
    x509_type: Optional[StrictStr] = Field('NONE', alias="x509Type", description="X.509 method that MongoDB Cloud uses to authenticate the database user.  - For application-managed X.509, specify `MANAGED`. - For self-managed X.509, specify `CUSTOMER`.  Users created with the `CUSTOMER` method require a Common Name (CN) in the **username** parameter. You must create externally authenticated users on the `$external` database.")
    __properties = ["awsIAMType", "databaseName", "deleteAfterDate", "groupId", "labels", "ldapAuthType", "links", "password", "roles", "scopes", "username", "x509Type"]

    @validator('aws_iam_type')
    def aws_iam_type_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('NONE', 'USER', 'ROLE'):
            raise ValueError("must validate the enum values ('NONE', 'USER', 'ROLE')")
        return v

    @validator('database_name')
    def database_name_validate_enum(cls, v):
        if v not in ('admin', '$external'):
            raise ValueError("must validate the enum values ('admin', '$external')")
        return v

    @validator('group_id')
    def group_id_validate_regular_expression(cls, v):
        if not re.match(r"^([a-f0-9]{24})$", v):
            raise ValueError(r"must validate the regular expression /^([a-f0-9]{24})$/")
        return v

    @validator('ldap_auth_type')
    def ldap_auth_type_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('NONE', 'GROUP', 'USER'):
            raise ValueError("must validate the enum values ('NONE', 'GROUP', 'USER')")
        return v

    @validator('x509_type')
    def x509_type_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('NONE', 'CUSTOMER', 'MANAGED'):
            raise ValueError("must validate the enum values ('NONE', 'CUSTOMER', 'MANAGED')")
        return v

    class Config:
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> DatabaseUser:
        """Create an instance of DatabaseUser from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                            "links",
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in labels (list)
        _items = []
        if self.labels:
            for _item in self.labels:
                if _item:
                    _items.append(_item.to_dict())
            _dict['labels'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in links (list)
        _items = []
        if self.links:
            for _item in self.links:
                if _item:
                    _items.append(_item.to_dict())
            _dict['links'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in roles (list)
        _items = []
        if self.roles:
            for _item in self.roles:
                if _item:
                    _items.append(_item.to_dict())
            _dict['roles'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in scopes (list)
        _items = []
        if self.scopes:
            for _item in self.scopes:
                if _item:
                    _items.append(_item.to_dict())
            _dict['scopes'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> DatabaseUser:
        """Create an instance of DatabaseUser from a dict"""
        if obj is None:
            return None

        if type(obj) is not dict:
            return DatabaseUser.parse_obj(obj)

        _obj = DatabaseUser.parse_obj({
            "aws_iam_type": obj.get("awsIAMType") if obj.get("awsIAMType") is not None else 'NONE',
            "database_name": obj.get("databaseName") if obj.get("databaseName") is not None else 'admin',
            "delete_after_date": obj.get("deleteAfterDate"),
            "group_id": obj.get("groupId"),
            "labels": [NDSLabel.from_dict(_item) for _item in obj.get("labels")] if obj.get("labels") is not None else None,
            "ldap_auth_type": obj.get("ldapAuthType") if obj.get("ldapAuthType") is not None else 'NONE',
            "links": [Link.from_dict(_item) for _item in obj.get("links")] if obj.get("links") is not None else None,
            "password": obj.get("password"),
            "roles": [Role.from_dict(_item) for _item in obj.get("roles")] if obj.get("roles") is not None else None,
            "scopes": [UserScope.from_dict(_item) for _item in obj.get("scopes")] if obj.get("scopes") is not None else None,
            "username": obj.get("username"),
            "x509_type": obj.get("x509Type") if obj.get("x509Type") is not None else 'NONE'
        })
        return _obj

