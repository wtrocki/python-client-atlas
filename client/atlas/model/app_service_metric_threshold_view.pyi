# coding: utf-8

"""
    MongoDB Atlas Administration API

    The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.  # noqa: E501

    The version of the OpenAPI document: 2.0
    Generated by: https://openapi-generator.tech
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from atlas import schemas  # noqa: F401


class AppServiceMetricThresholdView(
    schemas.ComposedBase,
    schemas.DictSchema
):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.

    Threshold for the metric that, when exceeded, triggers an alert. The metric threshold pertains to event types which reflects changes of measurements and metrics in the app services.
    """


    class MetaOapg:
        
        @staticmethod
        def discriminator():
            return {
                'metricName': {
                    'DataMetricThresholdView': DataMetricThresholdView,
                    'REALM_AUTH_LOGIN_FAIL': RawMetricThresholdView,
                    'REALM_ENDPOINTS_COMPUTE_MS': TimeMetricThresholdView,
                    'REALM_ENDPOINTS_EGRESS_BYTES': DataMetricThresholdView,
                    'REALM_ENDPOINTS_FAILED_REQUESTS': RawMetricThresholdView,
                    'REALM_ENDPOINTS_RESPONSE_MS': TimeMetricThresholdView,
                    'REALM_GQL_COMPUTE_MS': TimeMetricThresholdView,
                    'REALM_GQL_EGRESS_BYTES': DataMetricThresholdView,
                    'REALM_GQL_FAILED_REQUESTS': RawMetricThresholdView,
                    'REALM_GQL_RESPONSE_MS': TimeMetricThresholdView,
                    'REALM_OVERALL_COMPUTE_MS': TimeMetricThresholdView,
                    'REALM_OVERALL_EGRESS_BYTES': DataMetricThresholdView,
                    'REALM_OVERALL_FAILED_REQUESTS': RawMetricThresholdView,
                    'REALM_SDKFNS_FAILED_REQUESTS': RawMetricThresholdView,
                    'REALM_SDK_FNS_RESPONSE_MS': TimeMetricThresholdView,
                    'REALM_SDK_FUNCTIONS_COMPUTE_MS': TimeMetricThresholdView,
                    'REALM_SDK_FUNCTIONS_EGRESS_BYTES': DataMetricThresholdView,
                    'REALM_SDK_MQL_COMPUTE_MS': TimeMetricThresholdView,
                    'REALM_SDK_MQL_EGRESS_BYTES': DataMetricThresholdView,
                    'REALM_SDK_MQL_RESPONSE_MS': TimeMetricThresholdView,
                    'REALM_SYNC_CURRENT_OPLOG_LAG_MS_SUM': TimeMetricThresholdView,
                    'REALM_SYNC_EGRESS_BYTES': DataMetricThresholdView,
                    'REALM_SYNC_NUM_UNSYNCABLE_DOCS_PERCENT': RawMetricThresholdView,
                    'REALM_TRIGGERS_COMPUTE_MS': TimeMetricThresholdView,
                    'REALM_TRIGGERS_CURRENT_OPLOG_LAG_MS_SUM': TimeMetricThresholdView,
                    'REALM_TRIGGERS_EGRESS_BYTES': DataMetricThresholdView,
                    'REALM_TRIGGERS_FAILED_REQUESTS': RawMetricThresholdView,
                    'REALM_TRIGGERS_RESPONSE_MS': TimeMetricThresholdView,
                    'RawMetricThresholdView': RawMetricThresholdView,
                    'TimeMetricThresholdView': TimeMetricThresholdView,
                }
            }
        
        @classmethod
        @functools.lru_cache()
        def one_of(cls):
            # we need this here to make our import statements work
            # we must store _composed_schemas in here so the code is only run
            # when we invoke this method. If we kept this at the class
            # level we would get an error because the class level
            # code would be run when this module is imported, and these composed
            # classes don't exist yet because their module has not finished
            # loading
            return [
                RawMetricThresholdView,
                TimeMetricThresholdView,
                DataMetricThresholdView,
            ]


    def __new__(
        cls,
        *_args: typing.Union[dict, frozendict.frozendict, ],
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'AppServiceMetricThresholdView':
        return super().__new__(
            cls,
            *_args,
            _configuration=_configuration,
            **kwargs,
        )

from atlas.model.data_metric_threshold_view import DataMetricThresholdView
from atlas.model.raw_metric_threshold_view import RawMetricThresholdView
from atlas.model.time_metric_threshold_view import TimeMetricThresholdView
